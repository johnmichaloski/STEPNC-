<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>StepNC++: Variable.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<h1>Variable.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Variable.h : Declaration of the CVariable</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#pragma once</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor">#include "resource.h"</span>       <span class="comment">// main symbols</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include "NiStep_i.h"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "Symbol.h"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "Misc.h"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;atlstr.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "Globals.h"</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#if defined(_WIN32_WCE) &amp;&amp; !defined(_CE_DCOM) &amp;&amp; !defined(_CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA)</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#error "Single-threaded COM objects are not properly supported on Windows CE platform, such as the Windows Mobile platforms that do not include full DCOM support. Define _CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA to force ATL to support creating single-thread COM object's and allow use of it's single-threaded COM object implementations. The threading model in your rgs file was set to 'Free' as that is the only threading model supported in non DCOM Windows CE platforms."</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="keyword">class </span>CVarDef : 
<a name="l00020"></a>00020   <span class="keyword">public</span> CComObjectRootEx&lt;CComSingleThreadModel&gt;,
<a name="l00021"></a>00021   <span class="keyword">public</span> CComCoClass&lt;CVarDef, &amp;CLSID_Attribute&gt;,
<a name="l00022"></a>00022   <span class="keyword">public</span> IDispatchImpl&lt;IAttribute, &amp;IID_IAttribute, &amp;LIBID_NiStepLib, <span class="comment">/*wMajor =*/</span> 1, <span class="comment">/*wMinor =*/</span> 0&gt;,
<a name="l00023"></a>00023   <span class="keyword">public</span> ISymbolBase
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 {
<a name="l00026"></a>00026 <span class="keyword">public</span>:
<a name="l00027"></a>00027   CVarDef() {m_ref=0; }
<a name="l00028"></a>00028   CVarDef(<a class="code" href="classIStepNode.html">IStepNode</a> * owner, CString name, StepNodeType type=unknown_, DWORD ref=0, CString sClassname=L<span class="stringliteral">""</span>, <span class="keywordtype">int</span> bOptional=0)
<a name="l00029"></a>00029   { 
<a name="l00030"></a>00030     m_owner=owner;
<a name="l00031"></a>00031     m_sName=name; 
<a name="l00032"></a>00032     m_eType=type; 
<a name="l00033"></a>00033     this-&gt;m_ref=ref; 
<a name="l00034"></a>00034     this-&gt;m_sClassname=sClassname;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036     this-&gt;m_optBaseClassVars=<span class="keyword">new</span> CVarDefs;
<a name="l00037"></a>00037     this-&gt;m_eListType=unknown_;
<a name="l00038"></a>00038     m_bOptional= (bool) bOptional;
<a name="l00039"></a>00039     parentvardef=NULL;
<a name="l00040"></a>00040     _parentListPtr=NULL;
<a name="l00041"></a>00041   } 
<a name="l00042"></a>00042   ~CVarDef() {  }
<a name="l00043"></a>00043   CString &amp; Name() { <span class="keywordflow">return</span> m_sName; }
<a name="l00044"></a>00044   CString &amp; Classname() { <span class="keywordflow">return</span> m_sClassname; }
<a name="l00045"></a>00045   CString &amp; ListClassname() { <span class="keywordflow">return</span> m_sListClassname; }
<a name="l00046"></a>00046   StepNodeType &amp; Type() { <span class="keywordflow">return</span> m_eType; }
<a name="l00047"></a>00047   StepNodeType &amp; ListType() { <span class="keywordflow">return</span> m_eListType; }
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="preprocessor">#if 0</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>  StepNodeType &amp; ListType() { <span class="keywordflow">return</span> m_eListType; }
<a name="l00051"></a>00051   StepNodeType &amp; Type() { <span class="keywordflow">return</span> m_eType; }
<a name="l00052"></a>00052   CString &amp; Classname() { <span class="keywordflow">return</span> m_sClassname; }
<a name="l00053"></a>00053   CString &amp; ListClassname() { <span class="keywordflow">return</span> m_sListClassname; }
<a name="l00054"></a>00054   CString &amp;  TypeClassName()  { <span class="keywordflow">return</span> m_sClassname; }
<a name="l00055"></a>00055   CString   ExpressClassname() { <span class="keywordflow">return</span> ExpDemangle(Classname()); }
<a name="l00056"></a>00056   CString   ExpressListClassname() { <span class="keywordflow">return</span> ExpDemangle(m_sListClassname); }
<a name="l00057"></a>00057   <span class="keywordtype">bool</span> IsListType() { <span class="keywordflow">return</span> Type()== list_ || Type()== set_ || Type()== aggregate_ || Type()== array_ || Type()== bag_; }
<a name="l00058"></a>00058 <span class="preprocessor">#endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>  <span class="keywordtype">void</span> Init(<span class="keywordtype">int</span> nDimension, StepNodeType eListType , CString listclassname, <span class="keywordtype">int</span> min=1, <span class="keywordtype">int</span> max=-1)
<a name="l00060"></a>00060   {
<a name="l00061"></a>00061     m_sListClassname= listclassname;
<a name="l00062"></a>00062     this-&gt;m_nDimension=nDimension;
<a name="l00063"></a>00063     m_eListType=eListType;
<a name="l00064"></a>00064       
<a name="l00065"></a>00065   }
<a name="l00066"></a>00066   <span class="keyword">virtual</span> CString GetVarString(CString fmt=_T(<span class="stringliteral">""</span>)) ;
<a name="l00067"></a>00067   <span class="keyword">virtual</span> HRESULT SetVarString(CString val) ;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069   <span class="keyword">static</span> DWORD Find(CVarDefs &amp;vars, CString name)
<a name="l00070"></a>00070   {
<a name="l00071"></a>00071     CVarDefPtr vardef;
<a name="l00072"></a>00072     <span class="keywordflow">if</span>(NULL!=(vardef= FindVarDef(vars, name)))
<a name="l00073"></a>00073       <span class="keywordflow">return</span> vardef-&gt;m_ref;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     <span class="keywordflow">return</span> NULL;
<a name="l00076"></a>00076   }
<a name="l00077"></a>00077   <span class="keyword">static</span> CVarDefPtr FindVarDef(CVarDefs &amp;vars, CString &amp;name)
<a name="l00078"></a>00078   {
<a name="l00079"></a>00079     CVarDefPtr var;
<a name="l00080"></a>00080     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;vars.size(); i++)
<a name="l00081"></a>00081     {
<a name="l00082"></a>00082       <span class="keywordflow">if</span>(vars[i]-&gt;Type() == special_)
<a name="l00083"></a>00083       {
<a name="l00084"></a>00084         <span class="keywordflow">if</span>((var= FindVarDef((CVarDefs &amp;) *(CVarDefs*)vars[i]-&gt;m_ref, name))  != NULL)
<a name="l00085"></a>00085           <span class="keywordflow">return</span>  var;
<a name="l00086"></a>00086       }
<a name="l00087"></a>00087       <span class="keywordflow">if</span>(vars[i]-&gt;Name()==name) 
<a name="l00088"></a>00088         <span class="keywordflow">return</span> vars[i];
<a name="l00089"></a>00089     }
<a name="l00090"></a>00090     <span class="keywordflow">return</span> NULL;
<a name="l00091"></a>00091   }
<a name="l00092"></a>00092   <span class="keywordtype">bool</span> IsSimpleType(StepNodeType _eType=nulltype_) 
<a name="l00093"></a>00093   {
<a name="l00094"></a>00094     <span class="keywordflow">if</span>(_eType == nulltype_) 
<a name="l00095"></a>00095       _eType=m_eType; 
<a name="l00096"></a>00096     <span class="keywordflow">if</span>(_eType == special_)
<a name="l00097"></a>00097     {
<a name="l00098"></a>00098       CVarDefs &amp; vars = *(CVarDefs*) this-&gt;m_ref;
<a name="l00099"></a>00099       <span class="keywordflow">if</span>(vars.size() &gt; 1)
<a name="l00100"></a>00100         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00101"></a>00101       <span class="keywordflow">if</span>(vars.size() )
<a name="l00102"></a>00102         <span class="keywordflow">return</span> vars[0]-&gt;IsSimpleType() ;
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104     <span class="keywordflow">if</span>( _eType == string_  ||  _eType == integer_  ||  _eType == real_ ||  _eType == boolean_ ||  _eType == number_  ||  _eType == logical_ ||  _eType == enumeration_ )
<a name="l00105"></a>00105       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00106"></a>00106     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00107"></a>00107   }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   <span class="comment">//static bool IsListType(StepNodeType type ) { return type== list_ || type== set_ || type== aggregate_ || type== array_ || type== bag_; }</span>
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   <span class="keywordtype">bool</span> IsSimpleListType() ;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <a class="code" href="classIStepNode.html">IStepNode</a> * GetStepNodePtr() ;
<a name="l00114"></a>00114   CVarDefPtr GetPrimitiveVarDef();
<a name="l00115"></a>00115   <a class="code" href="classIStepNode.html">IStepNode</a> * &amp;Owner() { <span class="keywordflow">return</span>  m_owner; }
<a name="l00116"></a>00116   <span class="keywordtype">bool</span> &amp; Optional() { <span class="keywordflow">return</span> m_bOptional; }
<a name="l00117"></a>00117   <span class="keywordtype">long</span> &amp; Atom() { <span class="keywordflow">return</span> m_dwAtom; }
<a name="l00118"></a>00118   CVarDef * &amp; Parent() { <span class="keywordflow">return</span> parentvardef;  }
<a name="l00119"></a>00119 
<a name="l00121"></a>00121   DWORD m_ref;
<a name="l00122"></a>00122   LONG m_dwAtom;  <span class="comment">// maybe make this a property list ...</span>
<a name="l00123"></a>00123   <a class="code" href="classIStepNode.html">IStepNode</a> * _parentListPtr ;
<a name="l00124"></a>00124 <span class="keyword">private</span>:
<a name="l00125"></a>00125   CVarDef * parentvardef;
<a name="l00126"></a>00126   <a class="code" href="classIStepNode.html">IStepNode</a> * m_owner;
<a name="l00127"></a>00127   CVarDefs * m_optBaseClassVars;
<a name="l00128"></a>00128   <span class="keywordtype">bool</span> m_bOptional;
<a name="l00129"></a>00129   <span class="comment">// type information</span>
<a name="l00130"></a>00130   CString m_sReferenceChain;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="keyword">public</span>:
<a name="l00134"></a>00134 <span class="comment">// Object lifetime is managed locally. Not by COM</span>
<a name="l00135"></a>00135   STDMETHOD_(ULONG, AddRef)() { <span class="keywordflow">return</span> 1; }
<a name="l00136"></a>00136   STDMETHOD_(ULONG, Release)(){ <span class="keywordflow">return</span> 1;   }
<a name="l00137"></a>00137   STDMETHOD_(HRESULT, QueryInterface)( REFIID iid, LPVOID* ppInterface)\
<a name="l00138"></a>00138   {\
<a name="l00139"></a>00139     <span class="keywordflow">if</span> ( ppInterface == NULL)\
<a name="l00140"></a>00140       <span class="keywordflow">return</span> E_INVALIDARG;\
<a name="l00141"></a>00141     *ppInterface = NULL;  \
<a name="l00142"></a>00142     <span class="keywordflow">if</span> ( iid == IID_IUnknown )\
<a name="l00143"></a>00143       *ppInterface = (IUnknown*) (IDispatch*)  (CVarDef*)  <span class="keyword">this</span>;\
<a name="l00144"></a>00144     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( iid == IID_IAttribute)\
<a name="l00145"></a>00145       *ppInterface =  <span class="keyword">this</span>;\
<a name="l00146"></a>00146     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( iid == IID_IDispatch)\
<a name="l00147"></a>00147       *ppInterface = (IDispatch*) <span class="keyword">this</span>;\
<a name="l00148"></a>00148     <span class="keywordflow">else</span> <span class="keywordflow">return</span> E_FAIL;\
<a name="l00149"></a>00149     <span class="keywordflow">return</span> S_OK;\
<a name="l00150"></a>00150   }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="comment">// ISupportsErrorInfo</span>
<a name="l00153"></a>00153   STDMETHODDECL InterfaceSupportsErrorInfo (REFIID riid);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   STDMETHODDECL IsSimpleType (VARIANT_BOOL* flag) { *flag = IsSimpleType()? VARIANT_TRUE : VARIANT_FALSE; <span class="keywordflow">return</span> S_OK; }
<a name="l00157"></a>00157   STDMETHODDECL IsListType (VARIANT_BOOL* flag){*flag = ISymbolBase::IsListType()? VARIANT_TRUE : VARIANT_FALSE; <span class="keywordflow">return</span> S_OK;}
<a name="l00158"></a>00158   STDMETHODDECL get_Name (BSTR* pVal) { *pVal=Name().AllocSysString(); <span class="keywordflow">return</span> S_OK; }
<a name="l00159"></a>00159   STDMETHODDECL get_Classname (BSTR* pVal) { *pVal=ExpressClassname().AllocSysString(); <span class="keywordflow">return</span> S_OK; }
<a name="l00160"></a>00160   STDMETHODDECL get_Type (StepNodeType* pVal) { *pVal=Type();  <span class="keywordflow">return</span> S_OK; }
<a name="l00161"></a>00161   STDMETHODDECL get_ListType (StepNodeType* pVal) { *pVal=ListType(); <span class="keywordflow">return</span> S_OK; }
<a name="l00162"></a>00162   STDMETHODDECL get_ListClassname (BSTR* pVal) { *pVal=ExpressListClassname().AllocSysString(); <span class="keywordflow">return</span> S_OK; }
<a name="l00163"></a>00163   <span class="comment">//STDMETHODDECL Type(BSTR* pVal) { *pVal = Type();  return S_OK; }</span>
<a name="l00164"></a>00164   <span class="comment">//STDMETHODDECL Classname(BSTR* pVal) { *pVal=Classname().AllocSysString(); return S_OK; }</span>
<a name="l00165"></a>00165   <span class="comment">//STDMETHODDECL ListType(BSTR* pVal) { *pVal=ListType();  return S_OK; }</span>
<a name="l00166"></a>00166   STDMETHODDECL get_Atom (<span class="comment">/*[out, retval]*/</span> LONG * pVal) { *pVal = this-&gt;m_dwAtom; <span class="keywordflow">return</span> S_OK; }
<a name="l00167"></a>00167   STDMETHODDECL put_Atom (<span class="comment">/*in*/</span> LONG val){ m_dwAtom=val; <span class="keywordflow">return</span> S_OK; }
<a name="l00168"></a>00168   STDMETHODDECL get_Dimension (LONG * pVal) { *pVal=this-&gt;m_nDimension; <span class="keywordflow">return</span> S_OK; }
<a name="l00169"></a>00169   STDMETHODDECL IsSimpleListType (VARIANT_BOOL* flag){*flag = ISymbolBase::IsSimpleListType()? VARIANT_TRUE : VARIANT_FALSE; <span class="keywordflow">return</span> S_OK;}
<a name="l00170"></a>00170   STDMETHODDECL IsASimpleType(<span class="comment">/*[in]*/</span> BSTR bstrClassname, <span class="comment">/*[out, retval]*/</span>  VARIANT_BOOL* flag);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   STDMETHODDECL GetVarString (<span class="comment">/*[out, retval]*/</span> BSTR* pVal);
<a name="l00173"></a>00173   STDMETHODDECL GetStepNode (<span class="comment">/*[out, retval]*/</span> <a class="code" href="interfaceINode.html">INode</a> ** ppNode);
<a name="l00174"></a>00174   STDMETHODDECL Owner (<span class="comment">/*[out, retval]*/</span> <a class="code" href="interfaceINode.html">INode</a> ** ppNode);
<a name="l00175"></a>00175   STDMETHODDECL Clear ();
<a name="l00176"></a>00176   STDMETHODDECL SetStepNode (<span class="comment">/*[in]*/</span> <a class="code" href="interfaceINode.html">INode</a> * pNode);
<a name="l00177"></a>00177   STDMETHODDECL Clone (<span class="comment">/*[in]*/</span>  <a class="code" href="interfaceIAttribute.html">IAttribute</a> * pTo);
<a name="l00178"></a>00178   STDMETHODDECL GetInheritedAttributeList(<span class="comment">/*[out, retval]*/</span> IAttributeList ** pVal);
<a name="l00179"></a>00179   STDMETHODDECL GetNodeList(<span class="comment">/*[out, retval]*/</span> INodeList ** pVal);
<a name="l00180"></a>00180   STDMETHODDECL CreateNode(<span class="comment">/*[in]*/</span> BSTR classname, <span class="comment">/*[out, retval]*/</span> <a class="code" href="interfaceINode.html">INode</a> ** ppNode);
<a name="l00181"></a>00181   STDMETHODDECL ToXmlString(<span class="comment">/*[out, retval]*/</span> BSTR* bstrString);
<a name="l00182"></a>00182   STDMETHODDECL FromXmlString(<span class="comment">/*[in]*/</span> BSTR bstrString);
<a name="l00183"></a>00183   STDMETHODDECL TypeCheckXmlString(<span class="comment">/*[in]*/</span> BSTR bstrString, <span class="comment">/*[out,retval]*/</span> VARIANT_BOOL *bResult);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 };
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="keyword">typedef</span> std::vector&lt;CVarDefPtr&gt; Variables;
<a name="l00188"></a>00188 
</pre></div></div>
<html>
<body>
</body>
</html>
