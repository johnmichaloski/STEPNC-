<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>StepNC++: EListT&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>EListT&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="EListT" --><!-- doxytag: inherits="IStepNode" --><div class="dynheader">
Inheritance diagram for EListT&lt; T &gt;:</div>
<div class="dynsection">

<p><center><img src="classEListT.png" usemap="#EListT< T >_map" border="0" alt=""></center>
<map name="EListT< T >_map">
<area href="classIStepNode.html" alt="IStepNode" shape="rect" coords="0,0,77,24">
</map>
</div>

<p>
<a href="classEListT-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a970ae76cfe339cbe1f791e131c3c512"></a><!-- doxytag: member="EListT::Iterator" ref="a970ae76cfe339cbe1f791e131c3c512" args="" -->
typedef std::vector&lt; T &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>Iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9bfd1befcd10b621ac86a15a8d976a61"></a><!-- doxytag: member="EListT::RefmapIterator" ref="9bfd1befcd10b621ac86a15a8d976a61" args="" -->
typedef std::map&lt; T, Iterator &gt;<br class="typebreak">
::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>RefmapIterator</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="516795c70388ea7b8d0d344aae195e26"></a><!-- doxytag: member="EListT::AddRef" ref="516795c70388ea7b8d0d344aae195e26" args="()" -->
virtual ULONG STDMETHODCALLTYPE&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddRef</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#dba4e854541ad46b118150f8278bc489">clear</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#7b147db3986f2fdf9b06ee89ba1e016b">DeleteChild</a> (<a class="el" href="classIStepNode.html">IStepNode</a> *step)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#b2bf0e689f93dc17e568c19db2dbf123">erase</a> (int i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#d661a76e0e914e4f3ffe58eee03f3646">GetIndex</a> (CVarDefPtr vardef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2db64c9d85ce3d959155c6af68ad5821"></a><!-- doxytag: member="EListT::GetInstanceVars" ref="2db64c9d85ce3d959155c6af68ad5821" args="()" -->
virtual std::vector&lt; CVarDefPtr &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetInstanceVars</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7ae966ea4365c85a5b0022422d280ff"></a><!-- doxytag: member="EListT::GetInstanceVarsPtr" ref="b7ae966ea4365c85a5b0022422d280ff" args="()" -->
virtual std::vector&lt; CVarDefPtr &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetInstanceVarsPtr</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector&lt; CVarDefPtr &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#f8c6135f859889b0eda7d5e6a94705b2">GetVarDefs</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7263e61e2528ef7951ae04f602c7fc25"></a><!-- doxytag: member="EListT::GetVarDefsPtr" ref="7263e61e2528ef7951ae04f602c7fc25" args="()" -->
virtual std::vector&lt; CVarDefPtr &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetVarDefsPtr</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual CString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#11d082464997169731a0a213ade78441">GetVarString</a> (CString separator=_T(&quot;&quot;))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#bff0d3729f969331b70002137c0b3e22">Init</a> (CString classname, StepNodeType eListType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IStepNodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#d8cb687a8776bbc2078cf6993bdf8b33">InsertItem</a> (Iterator it)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#8f247f72b559e026440e598ace41903f">IsASimpleListType</a> (CString classname=L&quot;&quot;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a95ba9b13729ddc33aaea1c69556af1"></a><!-- doxytag: member="EListT::operator std::vector&lt; T &gt; &amp;" ref="1a95ba9b13729ddc33aaea1c69556af1" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator std::vector&lt; T &gt; &amp;</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#7015c7252f63313f102d973b891786f2">push_back</a> (T t, CString varname)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2c7f528b19fdca453b0b298d131c7b7"></a><!-- doxytag: member="EListT::Release" ref="e2c7f528b19fdca453b0b298d131c7b7" args="()" -->
virtual ULONG STDMETHODCALLTYPE&nbsp;</td><td class="memItemRight" valign="bottom"><b>Release</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#8502af89e2d2ef3aeb26978514f8d224">SetVarString</a> (CString str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#4944f92bfd9fbb92d716387e2c956ae1">size</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e0834dc0853538377163e57510da9ac"></a><!-- doxytag: member="EListT::STDMETHOD_" ref="5e0834dc0853538377163e57510da9ac" args="(HRESULT, QueryInterface)(REFIID iid" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>STDMETHOD_</b> (HRESULT, QueryInterface)(REFIID iid</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#502b9e10949369804293496a8f61b710">Store</a> (int i, IStepNodePtr val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEListT.html#8243219b88817ab5de223e09ff7544ef">Swap</a> (int n1, int n2)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eecd704cafd2afc14c343b7d339d21b3"></a><!-- doxytag: member="EListT::Create" ref="eecd704cafd2afc14c343b7d339d21b3" args="(const char *name)" -->
static IStepNodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>Create</b> (const char *name)</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4491bf90dcd575594e3f3d4786f4fd1b"></a><!-- doxytag: member="EListT::m_instancevars" ref="4491bf90dcd575594e3f3d4786f4fd1b" args="" -->
std::vector&lt; CVarDefPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_instancevars</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="93251f558aabee185795f5f6cb3969dc"></a><!-- doxytag: member="EListT::m_max" ref="93251f558aabee185795f5f6cb3969dc" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_max</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4eb64bc9435828b495fcb62c671bf1fa"></a><!-- doxytag: member="EListT::m_min" ref="4eb64bc9435828b495fcb62c671bf1fa" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_min</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84256cf684d82b98d5bf7c843c2779c7"></a><!-- doxytag: member="EListT::m_vars" ref="84256cf684d82b98d5bf7c843c2779c7" args="" -->
std::vector&lt; CVarDefPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_vars</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class EListT&lt; T &gt;</h3>

<a class="el" href="classEListT.html">EListT</a> is the 1D list class for the STEP Nodes. It takes a template &lt;class t&gt;=""&gt; declaration argument and is assumed to be of type IStepNodePtr. <a class="el" href="classEListT.html">EListT</a> itself is of type <a class="el" href="classIStepNode.html">IStepNode</a> so that it can treated like an IStepNodePtr, however, a reference to the <a class="el" href="classEListT.html">EListT</a> is passed around and not a pointer. Because of this <a class="el" href="classEListT.html">EListT</a> reference must always be greater than one because they cannot be deleted since they are not allocated on the heap. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dba4e854541ad46b118150f8278bc489"></a><!-- doxytag: member="EListT::clear" ref="dba4e854541ad46b118150f8278bc489" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the list of Step Node pointers and corresponding attributes variables. 
</div>
</div><p>
<a class="anchor" name="7b147db3986f2fdf9b06ee89ba1e016b"></a><!-- doxytag: member="EListT::DeleteChild" ref="7b147db3986f2fdf9b06ee89ba1e016b" args="(IStepNode *step)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HRESULT template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::DeleteChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIStepNode.html">IStepNode</a> *&nbsp;</td>
          <td class="paramname"> <em>step</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the first instance of the StepNode in the list. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns S_OK if delete was successful. Return E_FAIL if step node could not be found. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>step</em>&nbsp;</td><td>pointer to <a class="el" href="classIStepNode.html">IStepNode</a> derived class T item to delete. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b2bf0e689f93dc17e568c19db2dbf123"></a><!-- doxytag: member="EListT::erase" ref="b2bf0e689f93dc17e568c19db2dbf123" args="(int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the StepNode item at the index position in the list. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns S_OK if delete was successful. Return E_FAIL if step node could not be found. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>index of list position in which to delete item.. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d661a76e0e914e4f3ffe58eee03f3646"></a><!-- doxytag: member="EListT::GetIndex" ref="d661a76e0e914e4f3ffe58eee03f3646" args="(CVarDefPtr vardef)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::GetIndex           </td>
          <td>(</td>
          <td class="paramtype">CVarDefPtr&nbsp;</td>
          <td class="paramname"> <em>vardef</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the list attribute variables for a match to the given index_ attribute variable. The index_ attribute variable describes the index position within the list, which can be used to look up the corresponding StepNodePtr T.<p>
Returns -1 if the item could not be found.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vardef</em>&nbsp;</td><td>pointer to index_ attribute variable definition. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f8c6135f859889b0eda7d5e6a94705b2"></a><!-- doxytag: member="EListT::GetVarDefs" ref="f8c6135f859889b0eda7d5e6a94705b2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; CVarDefPtr &gt; &amp;template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::GetVarDefs           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the attribute variables for this list. The variable list contains a Variable definition (of type index_) for each IStepNodePtr in the actual list. 
<p>Reimplemented from <a class="el" href="classIStepNode.html">IStepNode</a>.</p>

</div>
</div><p>
<a class="anchor" name="11d082464997169731a0a213ade78441"></a><!-- doxytag: member="EListT::GetVarString" ref="11d082464997169731a0a213ade78441" args="(CString separator=_T(&quot;&quot;))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CString template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::GetVarString           </td>
          <td>(</td>
          <td class="paramtype">CString&nbsp;</td>
          <td class="paramname"> <em>separator</em> = <code>_T(&quot;&quot;)</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the list is a list of simple types (int, real, string, booleans, logical, enumerations), <dl class="return" compact><dt><b>Returns:</b></dt><dd>returns a delimted string representation of the list. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>separator</em>&nbsp;</td><td>to include between list items. </td></tr>
  </table>
</dl>

<p>Reimplemented from <a class="el" href="classIStepNode.html">IStepNode</a>.</p>

</div>
</div><p>
<a class="anchor" name="bff0d3729f969331b70002137c0b3e22"></a><!-- doxytag: member="EListT::Init" ref="bff0d3729f969331b70002137c0b3e22" args="(CString classname, StepNodeType eListType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::Init           </td>
          <td>(</td>
          <td class="paramtype">CString&nbsp;</td>
          <td class="paramname"> <em>classname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StepNodeType&nbsp;</td>
          <td class="paramname"> <em>eListType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the Step Node with list specific arguments. parses the string (optional ()) and uses commas to delimit the entries. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>classname</em>&nbsp;</td><td>string name of the list elements. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>eListType</em>&nbsp;</td><td>enumerated type of the list elements. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d8cb687a8776bbc2078cf6993bdf8b33"></a><!-- doxytag: member="EListT::InsertItem" ref="d8cb687a8776bbc2078cf6993bdf8b33" args="(Iterator it)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IStepNodePtr template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::InsertItem           </td>
          <td>(</td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>it</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a new Step Node item into the list of the given list element type at the given list iterator position. Saves the list item in the variable list if not simple list item. <dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the new StepNode that was inserted into the list at list position it. Returns NULL if the step node could not be created. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>it</em>&nbsp;</td><td>iterator into the list elements. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f247f72b559e026440e598ace41903f"></a><!-- doxytag: member="EListT::IsASimpleListType" ref="8f247f72b559e026440e598ace41903f" args="(CString classname=L&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::IsASimpleListType           </td>
          <td>(</td>
          <td class="paramtype">CString&nbsp;</td>
          <td class="paramname"> <em>classname</em> = <code>L&quot;&quot;</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if the given list or classname parameter is a simple list type (e.g. real, integer, enumeration, logical, boolean.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if theis list or the given classname are of a simple simple type. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>classname</em>&nbsp;</td><td>optional classname for testing. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7015c7252f63313f102d973b891786f2"></a><!-- doxytag: member="EListT::push_back" ref="7015c7252f63313f102d973b891786f2" args="(T t, CString varname)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::push_back           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CString&nbsp;</td>
          <td class="paramname"> <em>varname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores a StepNode class of derived type T at the back of the list. List size does not change. Adds a new element to the end of the list, after its current last element. The content of this new element is initialized to the pointer t.<p>
This increases the list size by one.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>t</em>&nbsp;</td><td>pointer to <a class="el" href="classIStepNode.html">IStepNode</a> derived class T. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>index of list position in which to store item. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8502af89e2d2ef3aeb26978514f8d224"></a><!-- doxytag: member="EListT::SetVarString" ref="8502af89e2d2ef3aeb26978514f8d224" args="(CString str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CString template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::SetVarString           </td>
          <td>(</td>
          <td class="paramtype">CString&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the list is a list of simple types (int, real, string, booleans, logical, enumerations), parses the string (optional ()) and uses commas to delimit the entries. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>to parse for list items. </td></tr>
  </table>
</dl>

<p>Reimplemented from <a class="el" href="classIStepNode.html">IStepNode</a>.</p>

</div>
</div><p>
<a class="anchor" name="4944f92bfd9fbb92d716387e2c956ae1"></a><!-- doxytag: member="EListT::size" ref="4944f92bfd9fbb92d716387e2c956ae1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the size of the list of Step Node pointers. </dd></dl>

</div>
</div><p>
<a class="anchor" name="502b9e10949369804293496a8f61b710"></a><!-- doxytag: member="EListT::Store" ref="502b9e10949369804293496a8f61b710" args="(int i, IStepNodePtr val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HRESULT template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::Store           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStepNodePtr&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores a StepNode into the list at the given index position. List size does not change. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns S_OK if store was successful. Return E_INVALIDARG if index i is out of range. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>index of list position in which to store item.. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8243219b88817ab5de223e09ff7544ef"></a><!-- doxytag: member="EListT::Swap" ref="8243219b88817ab5de223e09ff7544ef" args="(int n1, int n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void template&lt; class T &gt; <a class="el" href="classEListT.html">EListT</a>&lt; T &gt;::Swap           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps two members of the list. Both index must be valid or nothing is done. No error message. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1</em>&nbsp;</td><td>index one into the list. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n2</em>&nbsp;</td><td>index two into the list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="NiStep_2ExpressUtils_8h_source.html">NiStep/ExpressUtils.h</a><li><a class="el" href="doc_2ExpressUtils_8h_source.html">doc/ExpressUtils.h</a></ul>
</div>
<html>
<body>
</body>
</html>
